var documenterSearchIndex = {"docs":
[{"location":"3_graph_communities/#Community-Detection-Algorithms","page":"Community Detection Algorithms","title":"Community Detection Algorithms","text":"","category":"section"},{"location":"3_graph_communities/","page":"Community Detection Algorithms","title":"Community Detection Algorithms","text":"The primary function that this package includes is the compute function which implements different algorithms as methods using Julia's multiple dispatch.","category":"page"},{"location":"3_graph_communities/","page":"Community Detection Algorithms","title":"Community Detection Algorithms","text":"Louvain\nKClique\nLabelPropagation\nFastLPA\nPageRank\ncompute","category":"page"},{"location":"3_graph_communities/#GraphCommunities.Louvain","page":"Community Detection Algorithms","title":"GraphCommunities.Louvain","text":"Louvain <: CommunityDetectionAlgorithm\n\nThe Louvain algorithm for community detection in networks.\n\nThis method optimizes the modularity of partitions of the graph. It follows a greedy optimization approach that generally operates in time (O(n \\log n)) , making it efficient for large-scale networks.\n\nUsage\n\ncommunities = compute(Louvain(), graph)\n\nReferences\n\nBlondel, V. D., Guillaume, J. L., Lambiotte, R., & Lefebvre, E. (2008). Fast unfolding\n\nof communities in large networks. Journal of Statistical Mechanics: Theory and Experiment, 2008(10), P10008.\n\n\n\n\n\n","category":"type"},{"location":"3_graph_communities/#GraphCommunities.KClique","page":"Community Detection Algorithms","title":"GraphCommunities.KClique","text":"KClique <: CommunityDetectionAlgorithm\n\nThe K-Clique Percolation algorithm for community detection in networks.\n\nThis method identifies communities based on the presence of K-clique (with K = 3) structures within the graph, where a K-clique is a fully connected subgraph of K nodes. Two K-cliques are adjacent if they share K-1 nodes, and a community is defined as the union of K-cliques that can be reached from each other through a series of adjacent K-cliques.\n\nUsage\n\ncommunities = compute(KClique(), graph)\n\nReferences\n\nPalla, G., DerÃ©nyi, I., Farkas, I., & Vicsek, T. (2005). Uncovering the overlapping community structure of complex networks in nature and society. Nature, 435(7043), 814-818.\n\n\n\n\n\n","category":"type"},{"location":"3_graph_communities/#GraphCommunities.LabelPropagation","page":"Community Detection Algorithms","title":"GraphCommunities.LabelPropagation","text":"LabelPropagation <: CommunityDetectionAlgorithm\n\nThe Label Propagation algorithm for community detection in networks.\n\nThe Label Propagation algorithm identifies communities based on the diffusion of labels throughout the graph. Nodes adopt the label that is most common among their neighbors. This process iteratively refines labels until a consensus or stable state is reached, where nodes have predominantly the same label as their neighbors.\n\nThe algorithm can be run in either synchronous or asynchronous mode:\n\nSynchronous: All nodes update their labels simultaneously in each iteration.\nAsynchronous: Nodes update their labels in a random order.\n\nArguments\n\nsynchronous::Bool: If true, updates labels in synchronous mode; if false (default),\n\nupdates labels in asynchronous mode.\n\nmax_iter::Int: Maximum number of iterations (default is 100). If the algorithm doesn't\n\nconverge within this number of iterations, it will halt and return the current vector.\n\nUsage\n\ncommunities = compute(LabelPropagation(), graph)            # Asynchronous (default)\ncommunities = compute(LabelPropagation(sync=true), graph)   # Synchronous\n\nReferences\n\nRaghavan, U. N., Albert, R., & Kumara, S. (2007). Near linear time algorithm to detect\n\ncommunity structures in large-scale networks. Physical review E, 76(3), 036106.\n\n\n\n\n\n","category":"type"},{"location":"3_graph_communities/#GraphCommunities.FastLPA","page":"Community Detection Algorithms","title":"GraphCommunities.FastLPA","text":"FastLPA <: CommunityDetectionAlgorithm\n\nThe (Fast) Label Propagation algorithm for community detection in networks.\n\nThe Label Propagation algorithm identifies communities based on the diffusion of labels throughout the graph. Nodes adopt the label that is most common among their neighbors. This process iteratively refines labels until a consensus or stable state is reached, where nodes have predominantly the same label as their neighbors.\n\nThe algorithm can be run in either synchronous or asynchronous mode:\n\nSynchronous: All nodes update their labels simultaneously in each iteration.\nAsynchronous: Nodes update their labels in a random order (not yet implemented).\n\nArguments\n\nsynchronous::Bool: If true, updates labels in synchronous mode; if false (default),\n\nupdates labels in asynchronous mode.\n\nmax_iter::Int: Maximum number of iterations (default is 100). If the algorithm doesn't\n\nconverge within this number of iterations, it will halt and return the current vector.\n\nUsage\n\ncommunities = compute(FastLPA(), graph)            # Synchronous (default)\n\nReferences\n\nRaghavan, U. N., Albert, R., & Kumara, S. (2007). Near linear time algorithm to detect\n\ncommunity structures in large-scale networks. Physical review E, 76(3), 036106.\n\n\n\n\n\n","category":"type"},{"location":"3_graph_communities/#GraphCommunities.PageRank","page":"Community Detection Algorithms","title":"GraphCommunities.PageRank","text":"PageRank <: CommunityDetectionAlgorithm\n\nPageRank is an algorithm originally designed for ranking web pages in search results. However, it can also be used more broadly in networks to determine the importance of nodes within a graph. The underlying principle is that more important nodes are likely to receive more links from other nodes.\n\nThe algorithm computes a stationary distribution of a random walk on the graph where, at each step, with probability d, the walker randomly chooses an outgoing link from its current node and with probability 1 - d, it jumps to a random node in the graph.\n\nArguments\n\nd::Float64: Damping factor (default is 0.85). It represents the probability that the random walker follows an outgoing edge. Typically set between 0.85 and 0.9.\ntol::Float64: Tolerance for determining convergence (default is 1e-6). The algorithm stops iterating once the change between subsequent PageRank vectors is below this value.\nmax_iter::Int: Maximum number of iterations (default is 100). If the algorithm doesn't converge within this number of iterations, it will halt and return the current vector.\n\nUsage\n\npageranks = compute(PageRank(), graph)  # Using default parameters\npageranks = compute(PageRank(d=0.9, tol=1e-7, max_iter=150), graph)\n\nReferences\n\nPage, L., Brin, S., Motwani, R., & Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab.\n\n\n\n\n\n","category":"type"},{"location":"3_graph_communities/#GraphCommunities.compute","page":"Community Detection Algorithms","title":"GraphCommunities.compute","text":"compute(algo::LabelPropagation, g::SimpleGraph)::LabelArray\n\nDetect communities in a graph g using the Label Propagation algorithm.\n\nThe algorithm works by initially assigning each node a unique label. Then, in each iteration, each node adopts the label that is most frequent among its neighbors. The algorithm terminates when no node changes its label or after reaching a maximum number of iterations.\n\nArguments\n\nalgo::LabelPropagation: An instance indicating the settings of the Label Propagation algorithm.\ng::SimpleGraph: The graph on which to detect communities.\n\nReturns\n\nA LabelArray where each index corresponds to a vertex and its value indicates its community label.\n\nExample\n\njulia> using GraphCommunities\n\njulia> g = generate(KarateClub())\n\njulia> communities = compute(LabelPropagation(), g)\n\nNotes\n\nThe algorithm may not return the same community structure on different runs due to its heuristic nature. However, the structures should be reasonably similar and of comparable quality.\n\n\n\n\n\ncompute(algo::FastLPA, g::SimpleGraph)\n\nExecute the Fast Label Propagation algorithm on a graph.\n\nThis function processes a SimpleGraph using the Fast Label Propagation algorithm to perform community detection or labeling. It first preprocesses the graph to generate an edge list and the number of vertices, then applies synchronous label propagation if enabled.\n\nArguments\n\nalgo::FastLabelPropagation: The Fast Label Propagation algorithm instance.\ng::SimpleGraph: The graph to be processed, represented as a SimpleGraph.\n\nReturns\n\nIf algo.synchronous is true, it returns the result of synchronous label propagation; otherwise, it returns nothing.\n\nNotes\n\nThe graph g is first converted into an edge list and the number of vertices is determined.\nThis function delegates to _sync_label_propagation for the actual label propagation process.\nCurrently, only synchronous label propagation is implemented. If algo.synchronous is false, the function will return nothing.\n\nExample\n\njulia> g = generate(PlantedPartition())\n\njulia> compute(FastLPA(), g)\n\n\n\n\n\ncompute(algo::FastLPA, edge_list::Vector{Tuple{Int,Int}}, num_vertices::Int)\n\nExecute the Fast Label Propagation algorithm using a precomputed edge list.\n\nThis variant of the compute function allows for direct input of a graph's edge list and number of vertices. It's particularly useful when the edge list has been precomputed or when working with a graph representation that doesn't conform to a SimpleGraph.\n\nArguments\n\nalgo::FastLPA: The Fast Label Propagation algorithm instance.\nedge_list::Vector{Tuple{Int,Int}}: The edge list of the graph, where each edge is represented as a tuple of vertex indices.\nnum_vertices::Int: The number of vertices in the graph.\n\nReturns\n\nIf algo.synchronous is true, it returns the result of synchronous label propagation; otherwise, it returns nothing.\n\nNotes\n\nThe edge list should be lexicographically sorted and represent a valid graph.\nOnly synchronous label propagation is currently implemented.\n\n\n\n\n\ncompute(algo::FastLPA, g::SimpleWeightedGraph)\n\nExecute the Fast Label Propagation algorithm on a graph.\n\nThis function processes a SimpleWeightedGraph using the Fast Label Propagation algorithm to perform community detection or labeling. It first preprocesses the graph to generate an edge list and the number of vertices, then applies synchronous label propagation if enabled.\n\nArguments\n\nalgo::FastLabelPropagation: The Fast Label Propagation algorithm instance.\ng::SimpleWeightedGraph: The graph to be processed, represented as a SimpleWeightedGraph.\n\nReturns\n\nIf algo.synchronous is true, it returns the result of synchronous label propagation; otherwise, it returns nothing.\n\nNotes\n\nThe graph g is first converted into an edge list and the number of vertices is determined.\nThis function delegates to _sync_label_propagation for the actual label propagation process.\nCurrently, only synchronous label propagation is implemented. If algo.synchronous is false, the function will return nothing.\n\nExample\n\njulia> compute(FastLPA(), g)\n\n\n\n\n\ncompute(algo::Louvain, g::SimpleGraph)\n\nDetect communities in a graph g using the Louvain algorithm, a method based on modularity optimization.\n\nThe algorithm consists of two phases that are repeated iteratively:\n\nLocal Phase: Each node is moved to the community that yields the highest modularity gain.\nAggregation Phase: A new graph is constructed where nodes represent communities from the previous phase.\n\nThese phases are repeated until the modularity ceases to increase significantly.\n\nArguments\n\nalgo::Louvain: Indicates that the Louvain algorithm should be used for community detection.\ng::SimpleGraph: The graph on which to detect communities.\n\nReturns\n\nA dictionary mapping node IDs in the original graph to their respective community IDs.\n\nExample\n\njulia> using GraphCommunities\n\njulia> g = generate(PlantedPartition())\n\njulia> compute(Louvain(), g)\n\nNotes\n\nThe algorithm may not return the same community structure on different runs due to its heuristic nature. However, the structures should be reasonably similar and of comparable quality.\n\n\n\n\n\ncompute(algo::KClique, g::SimpleGraph)::Dict{Int, Int}\n\nDetect communities in a graph g using the K-Clique algorithm.\n\nThe function first finds triangles (or 3-cliques) in the graph. It then constructs a k-clique graph where nodes represent triangles, and edges indicate overlap. The connected components of this k-clique graph give the communities in the original graph.\n\nArguments\n\nalgo::KClique: Indicates that the K-Clique algorithm should be used for community detection.\ng::SimpleGraph: The graph on which to detect communities.\n\nReturns\n\nA dictionary mapping node IDs in the original graph to their respective community IDs.\n\nExample\n\njulia> using GraphCommunities\n\njulia> g = generate(KarateClub())\n\njulia> compute(KClique(), g)\n\nNotes\n\nCurrently, the implementation is restricted to 3-cliques (triangles). Future versions might support other clique sizes.\n\n\n\n\n\ncompute(algo::PageRank, g::AbstractGraph)::Vector{Float64}\n\nCompute the PageRank values of the nodes in graph g using the PageRank algorithm.\n\nArguments\n\nalgo::PageRank: The PageRank algorithm configuration object. This should contain properties like damping factor (d), maximum number of iterations (max_iter), and tolerance (tol).\ng::AbstractGraph: The graph for which to compute the PageRank. This can be a simple graph, directed graph, or a weighted version of these.\n\nReturns\n\nA vector of Float64 where each entry represents the PageRank value of the corresponding node in the graph.\n\nDetails\n\nThe function uses the power iteration method to compute the PageRank values. If the graph is weighted, the weights of the edges are taken into account while calculating the rank.\n\nThe algorithm iteratively refines the PageRank values until either the maximum number of iterations is reached or the values converge within the specified tolerance.\n\nExample\n\njulia> g = generate(PlantedPartition())\n\njulia> algo = PageRank(d=0.85, max_iter=100, tol=1e-6)\n\njulia> compute(algo, g)\n\n\n\n\n\n","category":"function"},{"location":"2_graph_generators/#Graph-Constructors","page":"Graph Constructors","title":"Graph Constructors","text":"","category":"section"},{"location":"2_graph_generators/","page":"Graph Constructors","title":"Graph Constructors","text":"The primary function for creating graphs to test community detection algorithms on is the generate function which implements different constructions as methods using Julia's multiple dispatch.","category":"page"},{"location":"2_graph_generators/","page":"Graph Constructors","title":"Graph Constructors","text":"ChainedCliques\nPlantedPartition\nKarateClub\ngenerate\ndraw_communities","category":"page"},{"location":"2_graph_generators/#GraphCommunities.ChainedCliques","page":"Graph Constructors","title":"GraphCommunities.ChainedCliques","text":"ChainedCliques <: CommunityGraph\n\nA graph structure that represents a series of connected cliques.\n\nFields\n\nnum_cliques::Int: The number of cliques in the graph.\nclique_size::Int: The number of nodes in each clique.\n\nExamples\n\ngraph_info = ChainedCliques(num_cliques=5, clique_size=4)\ngraph = generate(graph_info)\n\n\n\n\n\n","category":"type"},{"location":"2_graph_generators/#GraphCommunities.PlantedPartition","page":"Graph Constructors","title":"GraphCommunities.PlantedPartition","text":"PlantedPartition <: CommunityGraph\n\nThe PlantedPartition model, also known as the Stochastic Block Model (SBM), is a probabilistic model commonly used for generating synthetic networks with inherent community structures. This model creates a graph by partitioning nodes into distinct communities and then adding edges between nodes based on intra-community and inter-community probabilities.\n\nArguments\n\nn_communities::Int: Number of communities or blocks in the graph.\nnodes_per_community::Int: Number of nodes within each community.\npintra::Float64: Probability of creating an edge between two nodes within the same community. This defines the density of intra-community edges.\npinter::Float64: Probability of creating an edge between two nodes from different communities. This defines the sparsity of inter-community edges.\n\nTypically, pintra is set to be much larger than pinter to ensure dense intra-community connections and sparse inter-community connections, thereby creating discernible community structures.\n\nUsage\n\ngraph1 = generate(PlantedPartition())  # Using default parameters\ngraph2 = generate(PlantedPartition(n_communities=5, nodes_per_community=10, pintra=0.8, pinter=0.02))\n\nReferences\n\nHolland, P. W., Laskey, K. B., & Leinhardt, S. (1983). Stochastic blockmodels: First steps. Social networks, 5(2), 109-137.\n\n\n\n\n\n","category":"type"},{"location":"2_graph_generators/#GraphCommunities.KarateClub","page":"Graph Constructors","title":"GraphCommunities.KarateClub","text":"KarateClub <: CommunityGraph\n\nThe KarateClub graph, often referred to as the \"Zachary's Karate Club\", is a social network of friendships between 34 members of a karate club at a US university in the 1970s. This dataset has become a standard benchmark in community detection literature because of its well-documented community structure.\n\nThe graph captures the observed friendships between the 34 members. During the course of the study, the club split into two communities due to a conflict, making it a valuable dataset for studying community detection algorithms.\n\nUsage\n\ngraph = generate(KarateClub())\n\nReferences\n\nZachary, W. W. (1977). An information flow model for conflict and fission in small groups. Journal of anthropological research, 452-473.\n\n\n\n\n\n","category":"type"},{"location":"2_graph_generators/#GraphCommunities.generate","page":"Graph Constructors","title":"GraphCommunities.generate","text":"generate(structure::ChainedCliques)::SimpleGraph\n\nCreate a graph consisting of structure.r cliques, each of size structure.k, chained together.\n\nstructure.r represents the number of cliques.\nstructure.k represents the size of each clique.\n\nReturns a SimpleGraph with the chained cliques.\n\n\n\n\n\ngenerate(structure::PlantedPartition)::SimpleGraph\n\nGenerate a graph based on the planted partition model.\n\nstructure.n_communities is the number of communities.\nstructure.nodes_per_community denotes the number of nodes per community.\nstructure.pintra is the probability of an edge within a community.\nstructure.pinter is the probability of an edge between communities.\n\nReturns a SimpleGraph constructed based on the planted partition model.\n\n\n\n\n\ngenerate(structure::KarateClub)::SimpleGraph\n\nConstruct the famous Zachary's Karate Club graph. This graph represents the friendships between the 34 members of a karate club studied by Wayne W. Zachary in 1977.\n\nReturns a SimpleGraph representing the Karate Club network.\n\n\n\n\n\n","category":"function"},{"location":"2_graph_generators/#GraphCommunities.draw_communities","page":"Graph Constructors","title":"GraphCommunities.draw_communities","text":"draw_communities(g::AbstractGraph, communities::Dict)\n\nDraw the graph g with nodes colored based on their community assignments.\n\nArguments\n\ng::AbstractGraph: The input graph.\ncommunities::Dict: A dictionary mapping each vertex to its community.\n\nReturns\n\nA plot with nodes colored based on their community.\n\nNote\n\nThis function will only work if each node in the graph is assigned to a community.\n\n\n\n\n\ndraw_communities(g::AbstractGraph, node_labels::Vector{Tuple{Int, Int}})\n\nDraw the graph g with nodes colored based on their label assignments.\n\nArguments\n\ng::AbstractGraph: The input graph.\nnode_labels::Vector{Tuple{Int, Int}}: A vector of tuples, each containing a node and its label.\n\nReturns\n\nA plot with nodes colored based on their labels.\n\nExample\n\njulia> g = generate(KarateClub())\n\njulia> communities = compute(FastLPA(), g)\n\njulia> draw_communities(g, communities)\n\nNote\n\nThis function will only work if each node in the graph is included in the node_labels vector.\n\n\n\n\n\n","category":"function"},{"location":"4_experimental_algorithms/#Experimental-Algorithms","page":"Experimental Algorithms","title":"Experimental Algorithms","text":"","category":"section"},{"location":"4_experimental_algorithms/","page":"Experimental Algorithms","title":"Experimental Algorithms","text":"GraphCommunities.jl also includes a submodule for experimental graph algorithms designed by the author.","category":"page"},{"location":"4_experimental_algorithms/#The-enhanced_graph_kmeans-Algorithm","page":"Experimental Algorithms","title":"The enhanced_graph_kmeans Algorithm","text":"","category":"section"},{"location":"4_experimental_algorithms/","page":"Experimental Algorithms","title":"Experimental Algorithms","text":"The graph_kmeans algorithm is an adaptation of the traditional K-means clustering, tailored specifically for graphs. Instead of clustering based on the distances between data points in a Euclidean space (as in traditional K-means), graph_kmeans clusters vertices based on their structural roles and positions in a graph. When the parameter k is not given, both k and the initialization centroids are chosen by a custom method elaborated on below.","category":"page"},{"location":"4_experimental_algorithms/","page":"Experimental Algorithms","title":"Experimental Algorithms","text":"The enhanced_graph_kmeans algorithm builds upon the foundational graphkmeans method by incorporating additional stages designed to enhance the quality of clustering. Specifically, it utilizes triangle detection to densify the graph, aiding in the centroid initialization. After the graphkmeans clustering is done, it further refines the clusters using a label propagation method.","category":"page"},{"location":"4_experimental_algorithms/#Rationale:","page":"Experimental Algorithms","title":"Rationale:","text":"","category":"section"},{"location":"4_experimental_algorithms/","page":"Experimental Algorithms","title":"Experimental Algorithms","text":"Triangle Detection & Graph Densification: Triangles (subgraphs of 3 interconnected nodes) in a graph are indicative of tight-knit communities. By identifying these triangles, we can produce a denser graph representation that encapsulates stronger communal ties. This densified graph aids in centroid initialization by biasing it towards genuine community structures.","category":"page"},{"location":"4_experimental_algorithms/","page":"Experimental Algorithms","title":"Experimental Algorithms","text":"Label Propagation Refinement: After initial clustering with graph_kmeans, there might be nodes that are better suited for a neighboring cluster due to local community structure. Label propagation leverages the majority label among a node's neighbors to iteratively refine and update the cluster assignments, leading to more coherent communities.","category":"page"},{"location":"4_experimental_algorithms/#Algorithm-Description:","page":"Experimental Algorithms","title":"Algorithm Description:","text":"","category":"section"},{"location":"4_experimental_algorithms/","page":"Experimental Algorithms","title":"Experimental Algorithms","text":"Triangle Detection: Identify triangles within the graph to determine tightly-knit subgraphs.\nGraph Densification: Create a densified graph representation based on detected triangles.\nCentroid Initialization: Use the densified graph to initialize centroids for the K-means clustering.\nGraph K-means Clustering: Employ the graph_kmeans method to partition the graph into clusters.\nLabel Propagation: Refine the clusters from the previous step using a label propagation method to ensure nodes align with their local community structure.\nResult: Output refined clusters that are more representative of genuine community structures in the graph.","category":"page"},{"location":"4_experimental_algorithms/#Example","page":"Experimental Algorithms","title":"Example","text":"","category":"section"},{"location":"4_experimental_algorithms/","page":"Experimental Algorithms","title":"Experimental Algorithms","text":"julia> using GraphCommunities\n\njulia> using GraphCommunities.Experimental: graph_kmeans\n\njulia> using GraphCommunities.Experimental: enhanced_graph_kmeans\n\njulia> g = generate(KarateClub())\n\njulia> communities = enhanced_graph_kmeans(g)\n\njulia> draw_communities(g, communities)","category":"page"},{"location":"1_quick_start/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Start by importing the required modules:","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> using GraphCommunities\n\njulia> using GraphPlot: gplot # For visualizing the generated graphs","category":"page"},{"location":"1_quick_start/#Creating-Graphs-with-Community-Structure","page":"Quick Start Guide","title":"Creating Graphs with Community Structure","text":"","category":"section"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"A planted partition graph (also known as a stochastic block model) is a probabilistic graph model often used to generate synthetic networks with community structures for testing algorithms, especially community detection methods:","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> g = generate(PlantedPartition());\n\njulia> gplot(g)","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Another graph with community structure can be obtained by connecting num_cliques cliques, each with clique_size nodes, in a path like manor:","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> g = generate(ChainedCliques(;num_cliques=8, clique_size=5));\n\njulia> gplot(g)","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"This package also includes the well-known Karate Club Graph as an example dataset to test algorithms on:","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> g = generate(KarateClub());\n\njulia> gplot(g)","category":"page"},{"location":"1_quick_start/#Community-Detection-Algorithms","page":"Quick Start Guide","title":"Community Detection Algorithms","text":"","category":"section"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Detect communities using the Louvain Algorithm on a graph loaded from a csv edge list:","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> g = load_csv_graph(\"<path_to_your_graph>.csv\");\n\njulia> communities = compute(Louvain(), g); # Find communities using the Louvain algorithm\n\njulia> draw_communities(g, communities) # Draw the communities","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Detect communities using the K-clique Percolation Algorithm on a graph loaded from a csv edge list:","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> g = load_csv_graph(\"<path_to_your_graph>.csv\");\n\njulia> compute(KClique(), g);\n\njulia> draw_communities(g, communities) # Draw the communities","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Detect communities using the Label Propagation Algorithm on the famous Karate Club Graph using asynchronous label updates::","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> g = generate(KarateClub());\n\njulia> compute(LabelPropagation(), g);\n\njulia> draw_communities(g, communities) # Draw the communities","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Detect communities using the Label Propagation Algorithm on the famous Karate Club Graph using synchronous label updates:","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> g = generate(KarateClub());\n\njulia> compute(LabelPropagation(sync=true), g);\n\njulia> draw_communities(g, communities) # Draw the communities","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"We can also compute the Page Rank of each vertex (node) in the graph:","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> g = generate(KarateClub());\n\njulia> compute(PageRank(), g)","category":"page"},{"location":"1_quick_start/#Drawing-Communities","page":"Quick Start Guide","title":"Drawing Communities","text":"","category":"section"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"After detecting the communities, you can visualize them using the draw_communities function:","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> draw_communities(g, communities) # Draw the communities","category":"page"},{"location":"1_quick_start/#Saving-Graphs-and-Loading-Graphs","page":"Quick Start Guide","title":"Saving Graphs and Loading Graphs","text":"","category":"section"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"You can also save your graphs in various formats by using the GraphIO submodule:","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> using GraphCommunities.GraphIO: write_edgelist\n\njulia> g = generate(ChainedCliques(;num_cliques=2, clique_size=6));\n\njulia> write_edgelist(g, \"test-edgelist.csv\") # write to a .csv file\n\njulia> write_edgelist(g, \"test-edgelist.txt\") # write to a text file","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Similarily, you can use this submodule to load graphs:","category":"page"},{"location":"1_quick_start/","page":"Quick Start Guide","title":"Quick Start Guide","text":"julia> using GraphCommunities.GraphIO: load_edgelist\n\njulia> g1 = load_edgelist(\"test-edgelist.csv\")\n\njulia> g2 = load_edgelist(\"test-edgelist.txt\")","category":"page"},{"location":"#Welcome-to-GraphCommunities.jl","page":"Welcome to GraphCommunities.jl","title":"Welcome to GraphCommunities.jl","text":"","category":"section"},{"location":"","page":"Welcome to GraphCommunities.jl","title":"Welcome to GraphCommunities.jl","text":"GraphCommunities.jl is a Julia package that implements community detection algorithms on AbstractGraph types from Graphs.jl and SimpleWeightedGraphs.jl. It employs various community detection algorithms and also provides functionality for generating graphs with community structure. Currently, the package includes the following community detection algorithms:","category":"page"},{"location":"","page":"Welcome to GraphCommunities.jl","title":"Welcome to GraphCommunities.jl","text":"The Louvain Algorithm\nThe K-Clique Percolation Algorithm with K = 3\nThe Label Propagation Algorithm","category":"page"},{"location":"","page":"Welcome to GraphCommunities.jl","title":"Welcome to GraphCommunities.jl","text":"GraphCommunities.jl is designed to work seamlessly with the Graphs.jl package. All the graph structures, types, and utilities provided by Graphs.jl are the foundation of our package. This ensures compatibility, performance, and a familiar API for those already acquainted with Graphs.jl.","category":"page"},{"location":"","page":"Welcome to GraphCommunities.jl","title":"Welcome to GraphCommunities.jl","text":"If you're new to Graphs.jl, it's recommended to check out their documentation to get a deeper understanding of the graph structures and operations you can leverage.","category":"page"},{"location":"","page":"Welcome to GraphCommunities.jl","title":"Welcome to GraphCommunities.jl","text":"Finally, GraphCommunities.jl also has built in functionality for generating graphs with community like structure.","category":"page"},{"location":"#Installation","page":"Welcome to GraphCommunities.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome to GraphCommunities.jl","title":"Welcome to GraphCommunities.jl","text":"To add the GraphCommunities package to your Julia environment, you can use the Julia package manager. In the Julia REPL, enter the package manager by pressing ], then run:","category":"page"},{"location":"","page":"Welcome to GraphCommunities.jl","title":"Welcome to GraphCommunities.jl","text":"(@v1.x) pkg> add https://github.com/RandyRDavila/GraphCommunities.jl.git","category":"page"},{"location":"","page":"Welcome to GraphCommunities.jl","title":"Welcome to GraphCommunities.jl","text":"After the package is added, you can use it in your Julia sessions with:","category":"page"},{"location":"","page":"Welcome to GraphCommunities.jl","title":"Welcome to GraphCommunities.jl","text":"using GraphCommunities","category":"page"},{"location":"","page":"Welcome to GraphCommunities.jl","title":"Welcome to GraphCommunities.jl","text":"Author","category":"page"},{"location":"","page":"Welcome to GraphCommunities.jl","title":"Welcome to GraphCommunities.jl","text":"Randy R. Davila, PhD","category":"page"},{"location":"","page":"Welcome to GraphCommunities.jl","title":"Welcome to GraphCommunities.jl","text":"Lecturer of Computational Applied Mathematics & Operations Research at Rice University.\nSoftware Engineer at RelationalAI.","category":"page"}]
}
