<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Community Detection Algorithms · GraphCommunities.jl</title><meta name="title" content="Community Detection Algorithms · GraphCommunities.jl"/><meta property="og:title" content="Community Detection Algorithms · GraphCommunities.jl"/><meta property="twitter:title" content="Community Detection Algorithms · GraphCommunities.jl"/><meta name="description" content="Documentation for GraphCommunities.jl."/><meta property="og:description" content="Documentation for GraphCommunities.jl."/><meta property="twitter:description" content="Documentation for GraphCommunities.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GraphCommunities.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Welcome to GraphCommunities.jl</a></li><li><a class="tocitem" href="../1_quick_start/">Quick Start Guide</a></li><li><a class="tocitem" href="../2_graph_generators/">Graph Constructors</a></li><li class="is-active"><a class="tocitem" href>Community Detection Algorithms</a></li><li><a class="tocitem" href="../4_experimental_algorithms/">Experimental Algorithms</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Community Detection Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Community Detection Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/RandyRDavila/GraphCommunities.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/RandyRDavila/GraphCommunities.jl/blob/main/docs/src/3_graph_communities.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Community-Detection-Algorithms"><a class="docs-heading-anchor" href="#Community-Detection-Algorithms">Community Detection Algorithms</a><a id="Community-Detection-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Community-Detection-Algorithms" title="Permalink"></a></h1><p>The primary function that this package includes is the <code>compute</code> function which implements different algorithms as methods using Julia&#39;s multiple dispatch.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCommunities.Louvain" href="#GraphCommunities.Louvain"><code>GraphCommunities.Louvain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Louvain &lt;: CommunityDetectionAlgorithm</code></pre><p>The Louvain algorithm for community detection in networks.</p><p>This method optimizes the modularity of partitions of the graph. It follows a greedy optimization approach that generally operates in time (O(n \log n)) , making it efficient for large-scale networks.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">communities = compute(Louvain(), graph)</code></pre><p><strong>References</strong></p><ul><li>Blondel, V. D., Guillaume, J. L., Lambiotte, R., &amp; Lefebvre, E. (2008). Fast unfolding</li></ul><p>of communities in large networks. Journal of Statistical Mechanics: Theory and Experiment, 2008(10), P10008.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RandyRDavila/GraphCommunities.jl/blob/2f23b11c31a2402a83e054ff007c31f5ebd9ab00/src/GraphCommunities.jl#L45-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCommunities.KClique" href="#GraphCommunities.KClique"><code>GraphCommunities.KClique</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KClique &lt;: CommunityDetectionAlgorithm</code></pre><p>The K-Clique Percolation algorithm for community detection in networks.</p><p>This method identifies communities based on the presence of <code>K</code>-clique (with <code>K = 3</code>) structures within the graph, where a <code>K</code>-clique is a fully connected subgraph of <code>K</code> nodes. Two <code>K</code>-cliques are adjacent if they share <code>K-1</code> nodes, and a community is defined as the union of <code>K</code>-cliques that can be reached from each other through a series of adjacent <code>K</code>-cliques.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">communities = compute(KClique(), graph)</code></pre><p><strong>References</strong></p><ul><li>Palla, G., Derényi, I., Farkas, I., &amp; Vicsek, T. (2005). Uncovering the overlapping community structure of complex networks in nature and society. Nature, 435(7043), 814-818.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RandyRDavila/GraphCommunities.jl/blob/2f23b11c31a2402a83e054ff007c31f5ebd9ab00/src/GraphCommunities.jl#L70-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCommunities.LabelPropagation" href="#GraphCommunities.LabelPropagation"><code>GraphCommunities.LabelPropagation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LabelPropagation &lt;: CommunityDetectionAlgorithm</code></pre><p>The Label Propagation algorithm for community detection in networks.</p><p>The Label Propagation algorithm identifies communities based on the diffusion of labels throughout the graph. Nodes adopt the label that is most common among their neighbors. This process iteratively refines labels until a consensus or stable state is reached, where nodes have predominantly the same label as their neighbors.</p><p>The algorithm can be run in either synchronous or asynchronous mode:</p><ul><li><strong>Synchronous</strong>: All nodes update their labels simultaneously in each iteration.</li><li><strong>Asynchronous</strong>: Nodes update their labels in a random order.</li></ul><p><strong>Arguments</strong></p><ul><li><code>synchronous::Bool</code>: If <code>true</code>, updates labels in synchronous mode; if <code>false</code> (default),</li></ul><p>updates labels in asynchronous mode.</p><ul><li><code>max_iter::Int</code>: Maximum number of iterations (default is 100). If the algorithm doesn&#39;t</li></ul><p>converge within this number of iterations, it will halt and return the current vector.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">communities = compute(LabelPropagation(), graph)            # Asynchronous (default)
communities = compute(LabelPropagation(sync=true), graph)   # Synchronous</code></pre><p><strong>References</strong></p><ul><li>Raghavan, U. N., Albert, R., &amp; Kumara, S. (2007). Near linear time algorithm to detect</li></ul><p>community structures in large-scale networks. Physical review E, 76(3), 036106.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RandyRDavila/GraphCommunities.jl/blob/2f23b11c31a2402a83e054ff007c31f5ebd9ab00/src/GraphCommunities.jl#L93-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCommunities.FastLPA" href="#GraphCommunities.FastLPA"><code>GraphCommunities.FastLPA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FastLPA &lt;: CommunityDetectionAlgorithm</code></pre><p>The (Fast) Label Propagation algorithm for community detection in networks.</p><p>The Label Propagation algorithm identifies communities based on the diffusion of labels throughout the graph. Nodes adopt the label that is most common among their neighbors. This process iteratively refines labels until a consensus or stable state is reached, where nodes have predominantly the same label as their neighbors.</p><p>The algorithm can be run in either synchronous or asynchronous mode:</p><ul><li><strong>Synchronous</strong>: All nodes update their labels simultaneously in each iteration.</li><li><strong>Asynchronous</strong>: Nodes update their labels in a random order (not yet implemented).</li></ul><p><strong>Arguments</strong></p><ul><li><code>synchronous::Bool</code>: If <code>true</code>, updates labels in synchronous mode; if <code>false</code> (default),</li></ul><p>updates labels in asynchronous mode.</p><ul><li><code>max_iter::Int</code>: Maximum number of iterations (default is 100). If the algorithm doesn&#39;t</li></ul><p>converge within this number of iterations, it will halt and return the current vector.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">communities = compute(FastLPA(), graph)            # Synchronous (default)</code></pre><p><strong>References</strong></p><ul><li>Raghavan, U. N., Albert, R., &amp; Kumara, S. (2007). Near linear time algorithm to detect</li></ul><p>community structures in large-scale networks. Physical review E, 76(3), 036106.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RandyRDavila/GraphCommunities.jl/blob/2f23b11c31a2402a83e054ff007c31f5ebd9ab00/src/GraphCommunities.jl#L137-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCommunities.PageRank" href="#GraphCommunities.PageRank"><code>GraphCommunities.PageRank</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PageRank &lt;: CommunityDetectionAlgorithm</code></pre><p>PageRank is an algorithm originally designed for ranking web pages in search results. However, it can also be used more broadly in networks to determine the importance of nodes within a graph. The underlying principle is that more important nodes are likely to receive more links from other nodes.</p><p>The algorithm computes a stationary distribution of a random walk on the graph where, at each step, with probability <code>d</code>, the walker randomly chooses an outgoing link from its current node and with probability <code>1 - d</code>, it jumps to a random node in the graph.</p><p><strong>Arguments</strong></p><ul><li><code>d::Float64</code>: Damping factor (default is 0.85). It represents the probability that the random walker follows an outgoing edge. Typically set between 0.85 and 0.9.</li><li><code>tol::Float64</code>: Tolerance for determining convergence (default is 1e-6). The algorithm stops iterating once the change between subsequent PageRank vectors is below this value.</li><li><code>max_iter::Int</code>: Maximum number of iterations (default is 100). If the algorithm doesn&#39;t converge within this number of iterations, it will halt and return the current vector.</li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs">pageranks = compute(PageRank(), graph)  # Using default parameters
pageranks = compute(PageRank(d=0.9, tol=1e-7, max_iter=150), graph)</code></pre><p><strong>References</strong></p><ul><li>Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RandyRDavila/GraphCommunities.jl/blob/2f23b11c31a2402a83e054ff007c31f5ebd9ab00/src/GraphCommunities.jl#L180-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCommunities.compute" href="#GraphCommunities.compute"><code>GraphCommunities.compute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute(algo::LabelPropagation, g::SimpleGraph)::LabelArray</code></pre><p>Detect communities in a graph <code>g</code> using the Label Propagation algorithm.</p><p>The algorithm works by initially assigning each node a unique label. Then, in each iteration, each node adopts the label that is most frequent among its neighbors. The algorithm terminates when no node changes its label or after reaching a maximum number of iterations.</p><p><strong>Arguments</strong></p><ul><li><code>algo::LabelPropagation</code>: An instance indicating the settings of the Label Propagation algorithm.</li><li><code>g::SimpleGraph</code>: The graph on which to detect communities.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>LabelArray</code> where each index corresponds to a vertex and its value indicates its community label.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using GraphCommunities

julia&gt; g = generate(KarateClub())

julia&gt; communities = compute(LabelPropagation(), g)</code></pre><p><strong>Notes</strong></p><p>The algorithm may not return the same community structure on different runs due to its heuristic nature. However, the structures should be reasonably similar and of comparable quality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RandyRDavila/GraphCommunities.jl/blob/2f23b11c31a2402a83e054ff007c31f5ebd9ab00/src/algorithms/label-propagation.jl#L103-L131">source</a></section><section><div><pre><code class="language-julia hljs">compute(algo::FastLPA, g::SimpleGraph)</code></pre><p>Execute the Fast Label Propagation algorithm on a graph.</p><p>This function processes a SimpleGraph using the Fast Label Propagation algorithm to perform community detection or labeling. It first preprocesses the graph to generate an edge list and the number of vertices, then applies synchronous label propagation if enabled.</p><p><strong>Arguments</strong></p><ul><li><code>algo::FastLabelPropagation</code>: The Fast Label Propagation algorithm instance.</li><li><code>g::SimpleGraph</code>: The graph to be processed, represented as a SimpleGraph.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>algo.synchronous</code> is <code>true</code>, it returns the result of synchronous label propagation; otherwise, it returns <code>nothing</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The graph <code>g</code> is first converted into an edge list and the number of vertices is determined.</li><li>This function delegates to <code>_sync_label_propagation</code> for the actual label propagation process.</li><li>Currently, only synchronous label propagation is implemented. If <code>algo.synchronous</code> is <code>false</code>, the function will return <code>nothing</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; g = generate(PlantedPartition())

julia&gt; compute(FastLPA(), g)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RandyRDavila/GraphCommunities.jl/blob/2f23b11c31a2402a83e054ff007c31f5ebd9ab00/src/algorithms/fast-label-propagation.jl#L215-L245">source</a></section><section><div><pre><code class="language-julia hljs">compute(algo::FastLPA, edge_list::Vector{Tuple{Int,Int}}, num_vertices::Int)</code></pre><p>Execute the Fast Label Propagation algorithm using a precomputed edge list.</p><p>This variant of the <code>compute</code> function allows for direct input of a graph&#39;s edge list and number of vertices. It&#39;s particularly useful when the edge list has been precomputed or when working with a graph representation that doesn&#39;t conform to a SimpleGraph.</p><p><strong>Arguments</strong></p><ul><li><code>algo::FastLPA</code>: The Fast Label Propagation algorithm instance.</li><li><code>edge_list::Vector{Tuple{Int,Int}}</code>: The edge list of the graph, where each edge is represented as a tuple of vertex indices.</li><li><code>num_vertices::Int</code>: The number of vertices in the graph.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>algo.synchronous</code> is <code>true</code>, it returns the result of synchronous label propagation; otherwise, it returns <code>nothing</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The edge list should be lexicographically sorted and represent a valid graph.</li><li>Only synchronous label propagation is currently implemented.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RandyRDavila/GraphCommunities.jl/blob/2f23b11c31a2402a83e054ff007c31f5ebd9ab00/src/algorithms/fast-label-propagation.jl#L255-L276">source</a></section><section><div><pre><code class="language-julia hljs">compute(algo::FastLPA, g::SimpleWeightedGraph)</code></pre><p>Execute the Fast Label Propagation algorithm on a graph.</p><p>This function processes a <code>SimpleWeightedGraph</code> using the Fast Label Propagation algorithm to perform community detection or labeling. It first preprocesses the graph to generate an edge list and the number of vertices, then applies synchronous label propagation if enabled.</p><p><strong>Arguments</strong></p><ul><li><code>algo::FastLabelPropagation</code>: The Fast Label Propagation algorithm instance.</li><li><code>g::SimpleWeightedGraph</code>: The graph to be processed, represented as a SimpleWeightedGraph.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>algo.synchronous</code> is <code>true</code>, it returns the result of synchronous label propagation; otherwise, it returns <code>nothing</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The graph <code>g</code> is first converted into an edge list and the number of vertices is determined.</li><li>This function delegates to <code>_sync_label_propagation</code> for the actual label propagation process.</li><li>Currently, only synchronous label propagation is implemented. If <code>algo.synchronous</code> is <code>false</code>, the function will return <code>nothing</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; compute(FastLPA(), g)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RandyRDavila/GraphCommunities.jl/blob/2f23b11c31a2402a83e054ff007c31f5ebd9ab00/src/algorithms/fast-weighted-label-propagation.jl#L147-L175">source</a></section><section><div><pre><code class="language-julia hljs">compute(algo::Louvain, g::SimpleGraph)</code></pre><p>Detect communities in a graph <code>g</code> using the Louvain algorithm, a method based on modularity optimization.</p><p>The algorithm consists of two phases that are repeated iteratively:</p><ol><li>Local Phase: Each node is moved to the community that yields the highest modularity gain.</li><li>Aggregation Phase: A new graph is constructed where nodes represent communities from the previous phase.</li></ol><p>These phases are repeated until the modularity ceases to increase significantly.</p><p><strong>Arguments</strong></p><ul><li><code>algo::Louvain</code>: Indicates that the Louvain algorithm should be used for community detection.</li><li><code>g::SimpleGraph</code>: The graph on which to detect communities.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary mapping node IDs in the original graph to their respective community IDs.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using GraphCommunities

julia&gt; g = generate(PlantedPartition())

julia&gt; compute(Louvain(), g)</code></pre><p><strong>Notes</strong></p><p>The algorithm may not return the same community structure on different runs due to its heuristic nature. However, the structures should be reasonably similar and of comparable quality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RandyRDavila/GraphCommunities.jl/blob/2f23b11c31a2402a83e054ff007c31f5ebd9ab00/src/algorithms/louvain.jl#L36-L66">source</a></section><section><div><pre><code class="language-julia hljs">compute(algo::KClique, g::SimpleGraph)::Dict{Int, Int}</code></pre><p>Detect communities in a graph <code>g</code> using the K-Clique algorithm.</p><p>The function first finds triangles (or 3-cliques) in the graph. It then constructs a k-clique graph where nodes represent triangles, and edges indicate overlap. The connected components of this k-clique graph give the communities in the original graph.</p><p><strong>Arguments</strong></p><ul><li><code>algo::KClique</code>: Indicates that the K-Clique algorithm should be used for community detection.</li><li><code>g::SimpleGraph</code>: The graph on which to detect communities.</li></ul><p><strong>Returns</strong></p><ul><li>A dictionary mapping node IDs in the original graph to their respective community IDs.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using GraphCommunities

julia&gt; g = generate(KarateClub())

julia&gt; compute(KClique(), g)</code></pre><p><strong>Notes</strong></p><p>Currently, the implementation is restricted to 3-cliques (triangles). Future versions might support other clique sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RandyRDavila/GraphCommunities.jl/blob/2f23b11c31a2402a83e054ff007c31f5ebd9ab00/src/algorithms/k-clique.jl#L78-L107">source</a></section><section><div><pre><code class="language-julia hljs">compute(algo::PageRank, g::AbstractGraph)::Vector{Float64}</code></pre><p>Compute the PageRank values of the nodes in graph <code>g</code> using the PageRank algorithm.</p><p><strong>Arguments</strong></p><ul><li><p><code>algo::PageRank</code>: The PageRank algorithm configuration object. This should contain properties like damping factor (<code>d</code>), maximum number of iterations (<code>max_iter</code>), and tolerance (<code>tol</code>).</p></li><li><p><code>g::AbstractGraph</code>: The graph for which to compute the PageRank. This can be a simple graph, directed graph, or a weighted version of these.</p></li></ul><p><strong>Returns</strong></p><ul><li>A vector of <code>Float64</code> where each entry represents the PageRank value of the corresponding node in the graph.</li></ul><p><strong>Details</strong></p><p>The function uses the power iteration method to compute the PageRank values. If the graph is weighted, the weights of the edges are taken into account while calculating the rank.</p><p>The algorithm iteratively refines the PageRank values until either the maximum number of iterations is reached or the values converge within the specified tolerance.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; g = generate(PlantedPartition())

julia&gt; algo = PageRank(d=0.85, max_iter=100, tol=1e-6)

julia&gt; compute(algo, g)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RandyRDavila/GraphCommunities.jl/blob/2f23b11c31a2402a83e054ff007c31f5ebd9ab00/src/algorithms/pagerank.jl#L1-L35">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../2_graph_generators/">« Graph Constructors</a><a class="docs-footer-nextpage" href="../4_experimental_algorithms/">Experimental Algorithms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Saturday 28 October 2023 14:29">Saturday 28 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
